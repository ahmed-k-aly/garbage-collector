# garbage-collector
My implementation of a mark-sweep Garbage Collector with a best-fit allocator
## Mark & Sweep Garbage Collector:
A Mark & Sweep Garbage Collector consists of a mark phase, where the collector marks all the reachable and allocated nodes. Then, it is followed by a sweep phase, where the collector frees each unmarked allocated block. To do this, we usually need bits in the header of each block that represents whether this block is marked ot not.
A mark-sweep garbage collector needs to maintain a set of all the allocated blocks in a certain data structure.
Mark phase
Whenever an object is allocated in this configuration, its mark bit (in the block header) is cleared (set to 0). When the garbage collector is called, it traverses the root set of nodes. If you recall, the root set of nodes is the nodes that are outside the heap that point to nodes inside the heap, implying that a node in the heap is reachable. The root set could be traversed using any complete graph traversal algorithm, such as depth-first search or breadth-first search. Each time the search reaches a block inside the heap, it sets its mark bit to true (set to 1).  Once marking is complete, we trigger the sweep phase.
Sweep phase
In the sweep phase, we traverse the allocated blocks list through a normal search. Each time we reach a block, we check its mark bit in the header. If the mark bit is set, we clear it to prepare for another round of garbage collection. Else, if the bit is already cleared, we reclaim that block and free it by calling free(). Then, the garbage collector becomes idle again.

The mark-sweep garbage collector is very useful and has almost no overhead. However, it creates a problem of memory fragmentation. Imagine you have two blocks, A and B. Let’s say block A utilizes addresses 0–256 and block B uses addresses 256–512 in our address space. In this case, the next free block can only start from address 512. Let’s say we free block A. This way, we have 256 free bits or 8 bytes that we can’t really use since our program thinks the free space only starts from address number 256. Now let’s say we are running a program with thousands of blocks that get freed and allocated. This inefficiency simply becomes unacceptable with scale.

To overcome this, the garbage collector can maintain a set of the blocks that get freed. Every time we want to allocate a new block now, our program can just traverse the freed blocks set and follow a certain policy to determine how we can reallocate freed blocks. For instance, a best-fit policy simply traverses the freed blocks list whenever we want to allocate a new block. It searches for which freed block is the closest in size to the block we want to allocate now and returns it. Essentially, it keeps fragmenting the memory into the tiniest possible chunks. There are numerous other policies with their own studies that compare different policies in a way to find benchmarks for which policies are better to employ.
